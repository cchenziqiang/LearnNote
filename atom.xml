<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cchenziqiang.github.io</id>
    <title>Gridea</title>
    <updated>2020-04-30T13:54:24.585Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cchenziqiang.github.io"/>
    <link rel="self" href="https://cchenziqiang.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://cchenziqiang.github.io/images/avatar.png</logo>
    <icon>https://cchenziqiang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[计算机复试问题总结（1）]]></title>
        <id>https://cchenziqiang.github.io/post/ji-suan-ji-fu-shi-wen-ti-zong-jie-1/</id>
        <link href="https://cchenziqiang.github.io/post/ji-suan-ji-fu-shi-wen-ti-zong-jie-1/">
        </link>
        <updated>2020-04-30T13:39:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="计算机复试问题总结一">计算机复试问题总结（一）</h1>
<h3 id="1指令和数据放在一起存储的计算机是如何区分指令和数据的">1.指令和数据放在一起存储的，计算机是如何区分指令和数据的？</h3>
<p>方式一：通过不同时间段来区分指令和数据，即在取指令阶段（或取值微指令）取出的为指令，</p>
<p>在执行指令阶段（或相应微程序）取出的即为数据。</p>
<p>方式二：通过地址来源区分，由PC提供存储单元地址的取出的是指令，由指令地址码部分提供</p>
<p>存储单元地址的取出的是操作数</p>
<h3 id="2介绍自主控制机制和强制存储机制的区别">2.介绍自主控制机制和强制存储机制的区别</h3>
<p>自主存取控制方法：知定义各个用户对不同数据对象的存取对象。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。</p>
<p>强制存取控制方法：每一个数据对象被（强制地）标以一定的密集，每一个用户也被（强制地）授予某一个级别的许可，系统规定只有具有谋一许可证级别的用户才能存取某一个密级的数道据对象。</p>
<h3 id="3orm是什么">3.orm是什么</h3>
<p>ORM的全称是：Object Relational Mapping （对象 关系 映射）<br>
简单的说，orm是通过使用描述对象和数据之间映射的元数据，将程序中的对象自动持久化到关系数据库中。</p>
<p>ORM需要解决的问题是，能否把对象的数据直接保存到数据库中，又能否直接从数据库中拿到一个对象？要想做到上面两点，则必须要有映射关系。</p>
<p>ORM的优缺点<br>
优点：<br>
orm的技术特点，提高了开发效率。可以自动对实体Entity对象与数据库中的Table进行字段与属性的映射；不用直接SQL编码，能够像操作对象一样从数据库中获取数据<br>
缺点：<br>
orm会牺牲程序的执行效率和会固定思维模式，在从系统结构上来看，采用orm的系统多是多层系统的，系统的层次太多，效率就会降低，orm是一种完全面向对象的做法，所以面向对象的做法也会对性能产生一定的影响。<br>
总结：<br>
ORM只是一种帮助我们解决一些重复的、简单的劳动，我们不能一劳永逸的靠工具来解决问题，有些特殊问题还是需要进行特殊处理的。</p>
<h3 id="4什么是α测试什么是β测试">4.什么是α测试什么是β测试？</h3>
<p>α测试：Alpha测试（α测试）是由一个用户在开关环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由测试员完成。Alpha测试发现的错误，可以在测试现场立即发聩给开发人员，由开发人员及时分析和处理。目的是评价软件产品的功能，可使用性、可靠性、性能和支持。尤其注重产品的界面和特色。Aplha测试可以从软件产品编码结束之后开始，或在模块（子系统）测试完成后开始。有关的手册（草稿）等应该在Alpha测试前准备好。</p>
<p>β测试：Beta测试（β测试）是软件的多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。因而，Beta测试是在开发者无法控制的环境下进行的软件现场应用。在Beta测试中，由用户记下遇到的所有问题，包括真实的以及主管认定的，定期向开发者报告，开发者在综合用户的报告后，做出修改，最后将软件产品交付给全体用户使用。Beta测试着重于产品的支持性，包括文档、客户培训和支持产品的生产能力。只有当Alpha测试达到一定可靠程度后，才开始Beta测试。由于Beta测试的主要目标是测试可支持性，所以Beta测试应该尽可能由主持产品发行的人员来管理。</p>
<h3 id="5介绍瀑布模型和螺旋模型">5.介绍瀑布模型和螺旋模型</h3>
<p>瀑布模型（Waterfall Model） 是一个项目开发架构，开发过程是通过设计一系列阶段顺序展开的，从系统需求分析开始直到产品发布和维护，每个阶段都会产生循环<a href="https://baike.baidu.com/item/%E5%8F%8D%E9%A6%88/1448785">反馈</a>，因此，如果有信息未被覆盖或者发现了问题，那么最好 “返回”上一个阶段并进行适当的修改，项目开发进程从一个阶段“流动”到下一个阶段，这也是瀑布模型名称的由来。包括<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/25279">软件工程</a>开发、企业项目开发、产品生产以及市场销售等构造瀑布模型。</p>
<p>螺旋模型是一种演化<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B/3758917">软件开发过程</a>模型，它兼顾了<a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B/7432267">快速原型</a>的<a href="https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3/8415523">迭代</a>的特征以及<a href="https://baike.baidu.com/item/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B/9817778">瀑布模型</a>的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级的软件应用。</p>
<h3 id="6数据库系统和文件系统相比的优点">6.数据库系统和文件系统相比的优点</h3>
<p>1.安全性高，可靠性高<br>
2.查询检索速度快<br>
3.可以保证数据的有效性完整性和约束检查<br>
4.有效的解决并发操作的问题<br>
5.编程简单，操作方便。</p>
<figure data-type="image" tabindex="1"><img src="http://raw.githubusercontent.com/cchenziqiang/chen_Picgo/master/QQ%E6%88%AA%E5%9B%BE20200429155247.png" alt="" loading="lazy"></figure>
<h3 id="7ip层的协议有哪些">7.IP层的协议有哪些</h3>
<p>IP协议</p>
<p>ICMP协议：ICMP协议是指英文全称（Internet Control Message Protocol），就是网际控制信息协议。主要是用于补充IP传输数据报的过程中，发送主机无法确定数据报是否到达目标主机。ICMP报文分为出错报告报文和查询报文两种。若数据报不能到达目标主机，ICMP出错报告报文可以以回送信息的方式，向源主机发去信息，并不能纠抄正数据报中的任何出错。除了出错报告，ICMP还可以诊断出某些网络问题，这就是ICMP的查询报文。</p>
<p>IGMP协议：IGMP协议是指英文全称（Internet Group Management Protocol），网络组管理协议。主要用于建立和管理多播组，对IP分组广播进行控制</p>
<h3 id="8简述网卡的功能">8.简述网卡的功能</h3>
<p>1、网卡要进行串行/并行转换：</p>
<p>网卡和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的。而网卡和计算机之间的通信则是通过计算机主板上的I/O总线以并行传输方式进行。因此，网卡的一个重要功能就是要进行串行/并行转换。由于网络上的数据率和计算机总线上的数据率并不相同，因此在网卡中必须装有对数据进行缓存的存储芯片。</p>
<p>2、网卡能实现以太网协议：</p>
<p>在安装网卡时必须将管理网卡的设备驱动程序安装在计算机的操作系统中。这个驱动程序以后就会告诉网卡，应当从存储器的什么位置上将局域网传送过来的数据块存储下来。</p>
<p>3、网卡能处理正确的帧：</p>
<p>当网卡收到一个有差错的帧时，它就将这个帧丢弃而不必通知它所插入的计算机。当网卡收到一个正确的帧时，它就使用中断来通知该计算机并交付给协议栈中的网络层。当计算机要发送一个IP数据包时，它就由协议栈向下交给网卡组装成帧后发送到局域网。</p>
<h3 id="9完全测试是可能的吗">9.完全测试是可能的吗？</h3>
<p>完全测试是不可能 ，主要原因是：</p>
<ol>
<li>完全测试比较耗时，时间上不允许。</li>
<li>完全测试通常意味着较多资源投入，这在现实中往往是行不通的。</li>
<li>输入量太大，不能一一进行测试；</li>
<li>输出结果太多，只能分类进行验证；</li>
<li>软件实现途径太多；</li>
<li>软件产品说明书没有客观标准，从不同角度看，软件缺陷的标准不同。</li>
</ol>
<h3 id="10进程和线程的区别">10.进程和线程的区别</h3>
<p>根本区别：进程是资源分配最小单位，线程是程序执行的最小单位。 计算机在执行程序时，会为程序创建相应的进程，进行资源分配时，是以进程为单位进行相应的分配。每个进程都有相应的线程，在执行程序时，实际上是执行相应的一系列线程。</p>
<p>地址空间：进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段；线程没有独立的地址空间，同一进程的线程共享本进程的地址空间。</p>
<p>资源拥有：进程之间的资源是独立的；同一进程内的线程共享本进程的资源。</p>
<p>执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>线程是处理机调度的基本单位，但是进程不是。由于程序执行的过程其实是执行具体的线程，那么处理机处理的也是程序相应的线程，所以处理机调度的基本单位是线程。</p>
<p>系统开销：进程执行开销大，线程执行开销小。</p>
<h3 id="11什么是uml">11.什么是UML？</h3>
<p>UML-Unified Modeling Language <a href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/3160571">统一建模语言</a>，又称<a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80/10967573">标准建模语言</a>。是用来对软件密集系统进行可视化<a href="https://baike.baidu.com/item/%E5%BB%BA%E6%A8%A1">建模</a>的一种语言。UML的定义包括UML语义和UML表示法两个元素。</p>
<p>UML是在开发阶段，说明、可视化、构建和书写一个<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089">面向对象</a>软件密集系统的制品的开放方法。最佳的应用是工程实践，对大规模，复杂系统进行建模方面，特别是在<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/7485920">软件架构</a>层次，已经被验证有效。统一建模语言（UML）是一种模型化语言。模型大多以图表的方式表现出来。一份典型的建模图表通常包含几个块或框，连接线和作为模型附加信息之用的文本。这些虽简单却非常重要，在UML规则中相互联系和扩展。</p>
<h3 id="12系统测试和集成测试的区别">12.系统测试和集成测试的区别？</h3>
<p>1.测试对象不同: 系统测试对象是整个系统,包括系统中的硬件等;集成测试对象是模块之间的集成和调用关系。</p>
<p>2.测试方法不同: 系统测试一般由独立测试小组采用黑盒方式来测试;集成测试一般由开发小组采用白盒加黑盒的方式来测试。</p>
<p>3.测试依据不同: 系统测试依据是系统结构设计,目标说明书,需求说明书等;集成测试依据是程序结构设计。</p>
<h3 id="13事务的四大特性">13.事务的四大特性</h3>
<p> 原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。<br>
 一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。<br>
 隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。<br>
 持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。</p>
<h3 id="14大数据物联网和云计算的关系">14.大数据，物联网和云计算的关系</h3>
<p>身处信息快速发展的今天，物联网、大数据、云计算这些名词在我们的生活中出现的越来越频繁，看似高大上的三者其实却和我们的生活息息相关。带你来认识下三者之间的关系吧!</p>
<p>大数据</p>
<p>大数据(bigdata)，就是指种类多、流量大、容量大、价值高、处理和分析速度快的真实数据汇聚的产物。大数据或称巨量资料或海量数据资源，指的是所涉及的资料量规模巨大到无法透过目前主流软件工具，在合理时间内达到撷取、管理、处理、并整理成为帮助企业经营决策更积好目的的资讯。</p>
<p>大数据的4V特点：Volume、Velocity、Variety、Veracity。</p>
<p>即：数量Volume、多样性Variety、速度Velocity、和真实性Veracity。</p>
<p>经典应用案例：尿不湿和啤酒</p>
<p>在美国，到超市去买婴儿尿不湿是些年轻的父亲下班后的日常工作，而他们中有30%～40%的人同时也会为自己买些啤酒。产生这现象的原因是：美国的太太们常叮嘱她们的丈夫不要忘了下班后为小孩买尿不湿，而丈夫们在买尿不湿后又随手带回了他们喜欢的啤酒。另种情况是丈夫们在买啤酒时突然记起他们的责任，又去买了尿不湿。既然尿不湿与啤酒起被购买的机会很多，那么沃尔玛就在他们所有的门店里将尿不湿与啤酒并排摆放在起，结果是得到了尿不湿与啤酒的销售量双双增长。按常规思维，尿不湿与啤酒风马牛不相及，若不是借助数据挖掘技术对大量交易数据进行挖掘分析，沃尔玛是不可能发现数据内这有价值的规律的。</p>
<p>云计算</p>
<p>般来讲云计算，云端即是网络资源，从云端来按需获取所需要的服务内容就是云计算。云计算是指IT基础设施的交付和使用模式，指通过网络以按需、易扩展的方式获得所需的资源(硬件、平台、软件)。提供资源的网络被称为“云”。“云”中的资源在使用者看来是可以无限扩展的，并且可以随时获取，按需使用，随时扩展，按使用付费。这种特性经常被称为像水电样使用IT基础设施。广义的云计算是指服务的交付和使用模式，指通过网络以按需、易扩展的方式获得所需的服务。这种服务可以是IT和软件、互联网相关的，也可以是任意其他的服务。</p>
<p>经典应用案例：苹果icloud</p>
<p>苹果icloud不仅是个云端硬盘，它可让你轻松访问你所有苹果设备上的切内容，并自动同步所有设备中的文件、图片、音乐、日程表、邮件、联系人目录，更贴心的是，在你修改文件后还能自动将修改同步到所有苹果设备并对旧文件备份。你可以选择免费的5G存储空间，也可以每年花费24.99美元购买iTunesMatch服务，这样来，你可以通过任何苹果设备收听存放在苹果云服务器中的音乐。</p>
<p>物联网</p>
<p>简单理解：物物相连的互联网，即物联网。物联网在国际上又称为传感网，这是继计算机、互联网与移动通信网之后的又次信息产业浪潮。上的万事万物，小到手表、钥匙，大到汽车、楼房，只要嵌入个微型感应芯片，把它变得智能化，这个物体就可以“自动开口说话”。再借助无线网络技术，人们就可以和物体“对话”，物体和物体之间也能“交流”，这就是物联网。随着信息技术的发展，物联网行业应用版图不断增长。如：智能交通、环境保护、政府工作、公共安全、平安家居、智能消防、工业监测、老人护理、个人健康、花卉栽培、水系监测、食品溯源等。大的理想就是智慧地球，目前实际生活中存在并在建设的智慧城市都是物联网的概念。</p>
<p>经典应用案例：“翼机通+”</p>
<p>“翼机通+”虽然是款移动办公app，但它能够借助手机来刷考勤、刷门禁、刷消费、刷NFC标签巡检。而且“翼机通+”的受理版能够借助NFC手环等穿戴设备实现这些功能。</p>
<p>“翼机通+”机多用的理念正符合物联网的概念，用户只需使用手机或者受理版的穿戴设备就能代替原来的多卡时代。想象下，当你上班的时候可以用手机刷门禁、刷考勤;当你去食堂吃饭的时候不用花现金，也不用划饭卡，只要拿出手机“碰”下;当你坐地铁坐公交的时候，你可以将手机当成公交卡用;当你需要办公的时候不用打开电脑，在app中就可以完成工作内容;当你在巡检时只用带部手机就可以标记自己的路线。</p>
<p>大数据、云计算和物联网的关系</p>
<p>物联网对应了互联网的感觉和运动神经系统。云计算是互联网的核心硬件层和核心软件层的集合，也是互联网神经系统萌芽。大数据代表了互联网的信息层(数据海洋)，是互联网智慧和意识产生的基础。包括物联网，传统互联网，移动互联网在源源不断的向互联网大数据层汇聚数据和接受数据。云计算与物联网则推动了大数据的发展。<br>
原文链接：https://blog.csdn.net/duozhishidai/article/details/86538424</p>
<h3 id="15计算机网络红蓝军打仗问题可以实现吗">15.计算机网络红蓝军打仗问题可以实现吗？</h3>
<p>假设一支蓝军指挥官发出消息：“我建议在明天佛晓发起进攻，请确认。”如果消息到达了另一支蓝军，其指挥官同意这一建议，并且他的回信也安全的送到，那么能否进攻呢？不能。这是一个两步握手协议，因为该指挥官无法知道他的回信是否安全送到了，所以，他不能发起进攻，改进协议，将两步握手协议改为三步握手协议，这样，最初提出建议的指挥官必须确认对该建议的应答信息。假如信息没有丢失，并收到确认消息，则他必须将收到的确认信息告诉对方，从而完成三步握手协议。然而，这样他就无法知道消息是否被对方收到，因此，他不能发起进攻。那么现在采用四步握手协议会如何呢？结果仍是于事无补。</p>
<p>结论是：不存在使蓝军必胜的通信约定（协议）。</p>
<p>该结论可以用反证法证明，证明如下：假如存在某种协议，那么协议中最后一条信息要么是必要的，要么不是。如果不是，可以删除它，知道剩下的每条信息都是至关重要的。若最后一条消息没有安全到达目的地，则会怎样呢？刚才说过每条信息都是必要的，因此，若它丢了，则进攻不会如期进行。由于最后发出信息的指挥官永远无法确定该信息是否安全到达，所以他不会冒险发动攻击。同样，另一只蓝军也明白这个道理，所以也不会发动进攻。</p>
<p>Andrew使用上述问题来阐述网络传输成中“释放连接”问题的要点。而在实际中，当两台通过网络互联的计算机释放连接（对应两军问题的发起进攻），通常乙方收到对方确认的应答消息后不在回复就连接释放（用的是一个三步握手协议）。这样处理，协议并非完全没有错，但通常情况下以及足够了。）</p>
<p>就像andrew给出的结论那样，现在你应该很清楚，释放一个可能有数据丢失的网络连接并不像人们看起来那样简单。</p>
<h3 id="16简述链表和数组的优缺点">16.简述链表和数组的优缺点</h3>
<p><strong>数组的优点</strong></p>
<ul>
<li>随机访问性强</li>
<li>查找速度快</li>
</ul>
<p><strong>数组的缺点</strong></p>
<ul>
<li>插入和删除效率低</li>
<li>可能浪费内存</li>
<li>内存空间要求高，必须有足够的连续内存空间。</li>
<li>数组大小固定，不能动态拓展</li>
</ul>
<p><strong>链表的优点</strong></p>
<ul>
<li>插入删除速度快</li>
<li>内存利用率高，不会浪费内存</li>
<li>大小没有固定，拓展很灵活。</li>
</ul>
<p><strong>链表的缺点</strong></p>
<ul>
<li>不能随机查找，必须从第一个开始遍历，查找效率低</li>
</ul>
<h3 id="17重载和重写的区别">17.重载和重写的区别</h3>
<p>答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</p>
<h3 id="18面向对象的对象是什么对象之间是怎么作用的">18.面向对象的对象是什么，对象之间是怎么作用的</h3>
<p>在面向对象程序设计中，对象所指的是计算机系统中的某一个成分。在面向对象程序设计中，对象包含两个含义，其中一个是数据，另外一个是动作。对象则是数据和动作的结合体。对象不仅能够进行操作，同时还能够及时记录下操作结果。</p>
<h3 id="19数据库设计的过程">19.数据库设计的过程</h3>
<p><strong>需求分析</strong></p>
<p>调查和分析用户的业务活动和数据的使用情况，弄清所用数据的种类、范围、数量以及它们在业务活动中交流的情况，确定用户对<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F">数据库系统</a>的使用要求和各种约束条件等，形成用户需求规约。</p>
<p>需求分析是在用户调查的基础上，通过分析，逐步明确用户对系统的需求，包括数据需求和围绕这些数据的业务处理需求。在需求分析中，通过自顶向下，逐步分解的方法分析系统，分析的结果采用数据流程图(DFD**)**进行图形化的描述。</p>
<p><strong>概念设计</strong></p>
<p>对用户要求描述的现实世界(可能是一个工厂、一个商场或者一个学校等)，通过对其中诸处的分类、聚集和概括，建立抽象的<a href="https://baike.baidu.com/item/%E6%A6%82%E5%BF%B5%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">概念数据模型</a>。这个<a href="https://baike.baidu.com/item/%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B">概念模型</a>应反映现实世界各部门的<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E7%BB%93%E6%9E%84">信息结构</a>、信息流动情况、信息间的互相制约关系以及各部门对<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E5%82%A8%E5%AD%98">信息储存</a>、查询和加工的要求等。所建立的模型应避开数据库在计算机上的具体实现细节，用一种抽象的形式表示出来。以扩充的实体—（<a href="https://baike.baidu.com/item/E-R%E6%A8%A1%E5%9E%8B">E-R模型</a>）联系模型方法为例，第一步先明确现实世界各部门所含的各种实体及其属性、实体间的联系以及对信息的制约条件等，从而给出各部门内所用信息的局部描述(在数据库中称为用户的局部视图)。第二步再将前面得到的多个用户的局部视图集成为一个全局视图，即用户要描述的现实世界的<a href="https://baike.baidu.com/item/%E6%A6%82%E5%BF%B5%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">概念数据模型</a>。</p>
<p><strong>逻辑设计</strong></p>
<p>主要工作是将现实世界的概念<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">数据模型</a>设计成数据库的一种逻辑模式，即适应于某种特定<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a>所支持的逻辑<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F">数据模式</a>。与此同时，可能还需为各种数据处理应用领域产生相应的逻辑子模式。这一步设计的结果就是所谓“逻辑数据库”。</p>
<p><strong>物理设计</strong></p>
<p>根据特定<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a>所提供的多种<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">存储结构</a>和存取方法等依赖于具体计算机结构的各项物理设计措施，对具体的应用任务选定最合适的物理存储结构(包括文件类型、<a href="https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95">索引</a>结构和数据的存放次序与位逻辑等)、存取方法和存取路径等。这一步设计的结果就是所谓“物理数据库”。</p>
<p><strong>验证设计</strong></p>
<p>在上述设计的基础上，收集数据并具体建立一个数据库，运行一些典型的应用任务来验证数据库设计的正确性和合理性。一般，一个大型数据库的设计过程往往需要经过多次循环反复。当设计的某步发现问题时，可能就需要返回到前面去进行修改。因此，在做上述数据库设计时就应考虑到今后修改设计的可能性和方便性。</p>
<p><strong>运行与维护设计</strong></p>
<p>在<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F">数据库系统</a>正式投入运行的过程中，必须不断地对其进行调整与修改。</p>
<p>至今，数据库设计的很多工作仍需要人工来做，除了关系型数据库已有一套较完整的数据<a href="https://baike.baidu.com/item/%E8%8C%83%E5%BC%8F%E7%90%86%E8%AE%BA">范式理论</a>可用来部分地指导数据库设计之外，尚缺乏一套完善的数据库设计理论、方法和工具，以实现数据库设计的自动化或交互式的半自动化设计。所以数据库设计今后的研究发展方向是研究数据库设计理论，寻求能够更有效地表达语义关系的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">数据模型</a>，为各阶段的设计提供自动或半自动的设计工具和<a href="https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%8C%96">集成化</a>的<a href="https://baike.baidu.com/item/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">开发环境</a>，使数据库的设计更加工程化、更加规范化和更加方便易行，使得在数据库的设计中充分体现<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">软件工程</a>的先进思想和方法。</p>
<h3 id="20简述全局变量局部变量静态全局变量静态局部变量的区别">20.简述全局变量，局部变量，静态全局变量，静态局部变量的区别</h3>
<p>按存储区域分：全局变量、静态全局变量和静态局部变量都存放在内存的全局数据区，局部变量存放在内存的栈区</p>
<p>按作用域分：</p>
<p>1、全局变量在整个工程文件内都有效；</p>
<p>2、静态全局变量只在定义它的文件内有效；</p>
<p>3、静态局部变量只在定义它的函数内有效，且程序仅分配一次内存，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。<br>
4、全局变量和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。</p>
<p>5、静态局部变量与全局变量共享全局数据区，但静态局部变量只在定义它的函数中可见。静态局部变量与局部变量在存储位置上不同，使得其存在的时限也不同，导致对这两者操作 的运行结果也不同。</p>
<h3 id="21简述进程间通信的方式">21.简述进程间通信的方式</h3>
<p><strong>1. 管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。</strong></p>
<p>特点：</p>
<ol>
<li>它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</li>
<li>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</li>
<li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li>
</ol>
<p><strong>2. FIFO，也称为命名管道，它是一种文件类型。</strong></p>
<p>特点：</p>
<ol>
<li>FIFO可以在无关的进程之间交换数据，与无名管道不同。</li>
<li>FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</li>
</ol>
<p><strong>3. 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</strong></p>
<p>特点：</p>
<ol>
<li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li>
<li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</li>
<li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</li>
</ol>
<p><strong>4. 信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</strong></p>
<p>特点：</p>
<ol>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li>
<li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</li>
<li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li>
<li>支持信号量组</li>
</ol>
<p><strong>5. 共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。</strong></p>
<p>特点：</p>
<ol>
<li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li>
<li>因为多个进程可以同时操作，所以需要进行同步。</li>
<li>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li>
</ol>
<h3 id="22简述c和java编译的不同之处">22.简述C和JAVA编译的不同之处</h3>
<p><strong>1、Java编译过程与c/c++编译过程不同</strong></p>
<p>Java编译程序将java源程序编译成jvm可执行代码--java字节码.</p>
<p><strong>c/c++编译过程：</strong></p>
<p>当C编译器编译生成一个对象的代码时，该代码是为在某一特定硬件平台运行而生成的。因此在编译过程中，编译程序通过查表将所有对符号的引用转换为特定的内存偏移量，以保证程序运行。</p>
<p><strong>Java编译过程：</strong></p>
<p>Java编译器却不将对变量和方法的引用编译为数值引用，也不确定程序执行过程中的内存布局，而是将些符号引用信息保留在字节码中，由解释器在运行过程中创立内存布局，然后再通过查表来确定一个方法所在的地址，这样就有效地保证了java的可移植性和安全性。</p>
<p><strong>2、jvm工作原理</strong></p>
<p>运行jvm字符码的工作是由解释器来完成的。解释执行过程分三步进行：代码的装入、代码的校验、和代码的执行。</p>
<p>装入代码的工作由“类装载器classloader”完成。类装载器负责装入运行一个程序需要的所有代码，这也包括程序代码中的类所继承的类和被调用的类。当类装载器装入一个类时，该类被放在自己的名字空间中。除了通过符号引用自己名字空间以外的类，类之间没有其他办法可以影响其他类。在本台计算机的所有类都在同一地址空间中，而所有从外部引进的类，都有一个自己独立的名字空间。这使得本地类通过共享相同的名字空间获得较高的运行效率，同时又保证它们与从外部引进的类不会相互影响。</p>
<p>当装入了运行程序需要的所有类后，解释器便可确定整个可执行程序的内存布局。解释器为符号引用与特定的地址空间建立对应关系及查询表。通过在这一阶段确定代码的内布局，java很好地解决了由超类改变而使子类崩溃的问题，同时也防止了代码的非法访问。</p>
<p>随后，被装入的代码由字节码校验器进行检查。校验器可以发现操作数栈益处、非法数据类型转化等多种错误。通过校验后，代码便开始执行了。</p>
<p><strong>java字节码的执行有两种方式：</strong></p>
<p>1）即时编译方式：解释器先将字节编译成机器码，然后再执行该机器码。</p>
<p>2）解释执行方式：解释器通过每次解释并执行一小段代码来完成java字节码程序的所有操作。</p>
<h3 id="23网络的三网指哪些">23.网络的三网指哪些？</h3>
<p>电信网络，有线电视网络，计算机网络</p>
<h3 id="24heap和stack的概念及区别">24.Heap和Stack的概念及区别</h3>
<p><strong>一、堆栈空间分配区别：</strong><br>
　　1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；<br>
　　2、堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p>
<p><strong>二、堆栈缓存方式区别：</strong><br>
　　1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；<br>
　　2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p>
<p><strong>三、堆栈数据结构区别：</strong><br>
　　堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>
　　栈（数据结构）：一种先进后出的数据结构。</p>
<p><strong>四、Java中栈和堆的区别：</strong><br>
　　栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。<br>
　　在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。<br>
　　堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。<br>
<strong>五、Java中变量在内存中的分配：</strong><br>
　　1、类变量（static修饰的变量）：在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期–一直持续到整个”系统”关闭。<br>
　　2、实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存。<br>
　　3、局部变量：局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放。</p>
<h3 id="25交互式程序设计中非剥夺是不是一个好的策略">25.交互式程序设计中，非剥夺是不是一个好的策略</h3>
<p>非剥夺方式：分派程序一旦把处理机分配给某进程后，便让他一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。</p>
<p>剥夺方式：当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其他进程。</p>
<p>剥夺原则有:优先权原则，短进程优先原则，时间片原则等</p>
<p>在分时系统中，不剥夺不是一个好的策略，因为在分时系统中，除了交互性以外，及时性是很重要的性能因素。当一个作业被阻塞后，cpu就完全空闲了，别的用户的及时性就无法保证了，而完全可以把这些时间分配给别的作业运行，以提高系统吞吐量。</p>
<h3 id="26网络协议的三个核心要素">26.网络协议的三个核心要素</h3>
<p>语法，定义了数据与控制信息 的格式；</p>
<p>语义，定义了需要发出何种控制信息，完成何种响应动作，以及作出何种响应；</p>
<p>同步，定义了事件实现顺序的详细说明。</p>
<h3 id="27关系数据库有哪些操作特点是什么">27.关系数据库有哪些操作，特点是什么？</h3>
<p>查询：选择、投影、连接、除、并、交、差</p>
<p>数据更新：插入、删除、修改</p>
<p>关系操作的特点：集合操作方式，即操作的对象和结果都是集合。</p>
<h3 id="28为了实现重定位需要哪些硬件">28.为了实现重定位需要哪些硬件？</h3>
<p>最简单的方式是在系统中增设一个重定位寄存器，用来存放正在执行作业的内存地址，每次访问数据时，由硬件自动将相对地址和重定位寄存器中的起始地址相加，形成实际的物理地址。当然在分页式与分段式系统中，还有地址变换机构，以及块表等方式</p>
<h3 id="29数据库保护访问的内容有哪些">29.数据库保护（访问）的内容有哪些?</h3>
<p>数据库保护又叫做数据库控制，是通过四方面实现的，即安全性控制，<a href="https://baike.baidu.com/item/%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6">完整性控制</a>，<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E6%80%A7">并发性</a>控制和<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D">数据恢复</a>。</p>
<p>数据库的安全性是保护数据库，以防止因非法使用数据库，造成的数据泄漏，更改或破坏。</p>
<p>数据库的完整性是保护数据库中的数据正确性，有效性，相容性。</p>
<p><a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6">并发控制</a>是为了防止多个用户同时存取同一数据，造成的数据不一致。</p>
<p>数据库恢复是指将数据库从错误的状态恢复到某一已知的正确的状态。</p>
<h3 id="30系统调用的定义">30.系统调用的定义？</h3>
<p>系统调用是OS与应用程序之间的接口，它是用户程序取得OS服务的唯一途径。</p>
<p>它与一般的过程调用的区别：运行在不同的系统状态，调用程序运行在用户态，而被调用的程序运行在系统态，通过软中断机制，先由用户态转为系统态，经核心分析后，才转向相应的系统调用处理子程序；一般的过程调用返回后继续执行，但对系统调用，当调用进程仍具有最高优先权时，才返回到调用进程继续处理，否则只能等被重新调度。</p>
<h3 id="31解释一下管程">31.解释一下管程</h3>
<p>管程是由一组局部变量、对局部变量进行操作的一组过程和对局部变量进行初始化的语句序列组成。引入它的目的是因为Wait/Singal操作太过分散,对它的维护很麻烦且容易造成死锁。管程的特点是:管程的过程只能访问管程的局部变量,管程的局部变量只能由其过程来访问;任何时刻只能有一个进程进入管程执行;进程只能通管程提供的过程入口进入管程。</p>
<h3 id="32在可变分区管理中需要哪些硬件机制">32.在可变分区管理中,需要哪些硬件机制?</h3>
<p>采用可变分区方式管理时,一般均采用动态重定位方式装入作业。地址变换要靠硬件支持,主要是两个寄存器:基址寄存器和限长寄存器,限长寄存器存放作业所占分区的长度,基址寄存器则存放作业所占分区的起始地址,这两个值确定了一个分区的位置和大小。 <br>
转换时根据逻辑地址与限长值比较,如果不有超过这个值,表示访问地址合法,再加上基址寄存器中的值就得到了绝对地址了,否则形成“地址越界”中断。</p>
<h3 id="33中断和陷入有什么异同">33.中断和陷入有什么异同</h3>
<p>外中断时指来自处理机和内存外部的中断,如I/O中断、定时器中断、外部信号中断等。狭义上也叫中断; <br>
内中断主要指在处理机和内存内部产生的中断,也称陷入,如校验错、页面失效、溢出、除数为零等。</p>
<p>中断和陷阱的主要区别: <br>
(1) 陷入通常由处理机正在执行的现行指令引起,而中断则是由与现行指令无关的中断源引起的。</p>
<p>(2) 陷阱处理程序提供的服务为当前进程所用,而中断处理程序提供的服务则不是为了当前进程的。</p>
<p>(3) CPU在执行完一条指令之后,下一条指令开始之前响应中断,而在一条指令执行中也可以响应陷阱。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://cchenziqiang.github.io/post/hello-gridea/</id>
        <link href="https://cchenziqiang.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>